<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Le Micro Climat du Balcon de Jonathan - IoT</title>

<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Chart.js and date adapter -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

<style>
  body { background-color: #111827; }
  .controls-panel { z-index: 10; }
  #iaqCard { width: 140px; height: 140px; }
  #iaqGauge { display: block; }
  .iaq-segment { transition: transform 220ms ease, filter 220ms ease; transform-origin: 80px 80px; }
  .iaq-active { filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6)); }

  /* simple fullscreen loading overlay */
  #loadingOverlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(2,6,23,0.6);
    z-index: 50;
    color: #e5e7eb;
    font-size: 1rem;
  }
</style>
</head>
<body class="font-sans text-gray-100">

<!-- Loading overlay -->
<div id="loadingOverlay">Récupération des données historiques… merci de patienter.</div>

<!-- Top Navigation -->
<header class="bg-gray-800 shadow-lg">
  <div class="container mx-auto flex items-center justify-between p-4">
    <h1 class="text-2xl font-bold text-green-400">Mais alors, quel temps fait-il sur le balcon de Jonathan?</h1>
    <p id="lastUpdate" class="text-gray-400">Les dernières données météorologiques datent de: --</p>
  </div>
</header>

<!-- Main Content -->
<main class="container mx-auto p-6 space-y-6">
  <!-- Cards Grid -->
  <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
    <div class="bg-gray-800 rounded-xl shadow-lg p-5 flex flex-col items-center justify-center">
      <h2 class="text-gray-400 mb-2 text-sm sm:text-base">Température</h2>
      <p id="tempValue" class="text-2xl sm:text-3xl font-bold text-green-400">-- °C</p>
    </div>

    <div class="bg-gray-800 rounded-xl shadow-lg p-5 flex flex-col items-center justify-center">
      <h2 class="text-gray-400 mb-2 text-sm sm:text-base">Pression</h2>
      <p id="pressureValue" class="text-2xl sm:text-3xl font-bold text-red-400">-- hPa</p>
    </div>

    <div class="bg-gray-800 rounded-xl shadow-lg p-5 flex flex-col items-center justify-center">
      <h2 class="text-gray-400 mb-2 text-sm sm:text-base">Hygrométrie</h2>
      <p id="moistureValue" class="text-2xl sm:text-3xl font-bold text-teal-400">-- %</p>
    </div>

    <div class="bg-gray-800 rounded-xl shadow-lg p-5 flex flex-col items-center justify-center">
      <h2 class="text-gray-400 mb-2 text-sm sm:text-base">IAQ</h2>

      <div id="iaqCard" class="flex items-center justify-center relative">
        <svg id="iaqGauge" width="140" height="140" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"></svg>
        <div class="absolute flex flex-col items-center justify-center">
          <span id="iaqValue" class="text-l sm:text-l font-bold transition-colors duration-500 leading-none">--</span>
          <span id="iaqGradeLabel" class="text-xs text-gray-300 mt-1 leading-none">--</span>
          <span id="iaqprecisionValue" class="text-[10px] text-gray-500 mt-0.5 italic leading-none">-</span>
        </div>
      </div>
    </div>

    <div class="bg-gray-800 rounded-xl shadow-lg p-5 flex flex-col items-center justify-center">
      <h2 class="text-gray-400 mb-2 text-sm sm:text-base">Quantité de CO2</h2>
      <p id="co2value" class="text-2xl sm:text-3xl font-bold text-pink-400">--</p>
    </div>

    <div class="bg-gray-800 rounded-xl shadow-lg p-5 flex flex-col items-center justify-center">
      <h2 class="text-gray-400 mb-2 text-sm sm:text-base">Qualité de COV</h2>
      <p id="vocValue" class="text-2xl sm:text-3xl font-bold text-cyan-400">--</p>
    </div>
  </div>

  <!-- Chart Panel -->
  <div class="bg-gray-800 rounded-xl shadow-lg p-6">
    <div class="controls-panel mb-4">
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <h2 class="text-xl font-semibold">Imagine si on avait accès à l'historique des données, ça serait fou non ?</h2>

        <div class="flex flex-wrap items-center gap-2 justify-end">
          <div class="flex flex-col sm:flex-row sm:items-center gap-1 w-full sm:w-auto">
            <label for="variableSelect" class="text-gray-300 text-sm break-words pr-2 sm:pr-0">Alors, tu veux regarder quoi ?</label>
            <select id="variableSelect" class="bg-gray-700 text-gray-100 rounded px-3 py-1 text-sm w-full sm:w-44 max-w-xs">
              <option value="field1" selected>Température</option>
              <option value="field2">Pression</option>
              <option value="field3">Hygrométrie</option>
              <option value="field4">IAQ</option>
              <option value="field5">IAQ précision</option>
              <option value="field6">CO2</option>
              <option value="field7">COV</option>
            </select>
          </div>

          <div class="flex flex-col sm:flex-row sm:items-center gap-1 w-full sm:w-auto">
            <label for="timeRangeSelect" class="text-gray-300 text-sm break-words pr-2 sm:pr-0">Sur quelle période?</label>
            <select id="timeRangeSelect" class="bg-gray-700 text-gray-100 rounded px-3 py-1 text-sm w-full sm:w-44 max-w-xs">
              <option value="1h">La dernière heure</option>
              <option value="24h" selected>Les dernières 24h</option>
              <option value="7d">Les 7 jours passés</option>
              <option value="30d">Le mois passé</option>
              <option value="1y">L'année passée</option>
              <option value="all">Allez balance tout</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <div class="w-full">
      <div class="relative w-full h-48 sm:h-64 md:h-80">
        <canvas id="dataChart" class="w-full h-full"></canvas>
      </div>
    </div>
  </div>
</main>

<script>
const apiKey = "EAG5JSOPGG6TUX2V";
const channelID = "3110199";

let chart = null;
let cachedFeeds = null; // store fetched feeds

const maxPoints = Infinity; // keep all points (still safe because we may downsample later if needed)

const fieldLabels = {
  field1: {label: "Température (°C)", color: "rgb(34,197,94)"},
  field2: {label: "Pression (hPa)", color: "rgb(239,68,68)"},
  field3: {label: "Hygrométrie (%)", color: "rgb(20,184,166)"},
  field4: {label: "IAQ", color: "rgb(59,130,246)"},
  field5: {label: "IAQ précision", color: "rgb(234,179,8)"},
  field6: {label: "CO2 (ppm)", color: "rgb(236,72,153)"},
  field7: {label: "COV (ppm)", color: "rgb(6,182,212)"}
};

const rangeDurationsMs = {
  '1h': 60 * 60 * 1000,
  '24h': 24 * 60 * 60 * 1000,
  '7d': 7 * 24 * 60 * 60 * 1000,
  '30d': 30 * 24 * 60 * 60 * 1000,
  '1y': 365 * 24 * 60 * 60 * 1000,
  'all': Infinity
};

const iaqGrades = [
  { name: 'Très bon', color: '#16a34a' },
  { name: 'Bon',     color: '#22c55e' },
  { name: 'Moyen',   color: '#f59e0b' },
  { name: 'Médiocre',color: '#f97316' },
  { name: 'Mauvais', color: '#ef4444' }
];

function showLoading(show) {
  const o = document.getElementById('loadingOverlay');
  if (!o) return;
  o.style.display = show ? 'flex' : 'none';
}

/*
  Robust getData() that:
  - requests up to pageSize entries per call using the "end" param,
  - loops backwards in time until ThingSpeak returns fewer than pageSize items,
  - removes duplicates and sorts old->new.
*/
async function getData() {
  if (cachedFeeds) return cachedFeeds;

  showLoading(true);
  const pageSize = 8000; // ThingSpeak limit per request
  let allFeeds = [];
  let end = new Date(); // start from now (newest)
  let keepGoing = true;
  let round = 0;
  const seenIds = new Set();

  try {
    while (keepGoing && round < 100) { // safety cap
      const endISO = end.toISOString();
      const url = `https://api.thingspeak.com/channels/${channelID}/feeds.json?api_key=${apiKey}&results=${pageSize}&end=${encodeURIComponent(endISO)}`;
      // console.log('Fetching', url);
      const res = await fetch(url);
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      const feeds = Array.isArray(data.feeds) ? data.feeds : [];

      if (feeds.length === 0) break;

      // Append feeds to allFeeds (we'll dedupe/sort later)
      for (const f of feeds) {
        // if entry_id exists, use it to deduplicate
        if (f.entry_id && seenIds.has(String(f.entry_id))) continue;
        if (f.entry_id) seenIds.add(String(f.entry_id));
        allFeeds.push(f);
      }

      // Determine the oldest timestamp returned and step end backwards
      // Note: feeds may come in newest-first or oldest-first depending on TS; be defensive
      const createdTimes = feeds.map(x => Date.parse(x.created_at)).filter(t => !isNaN(t));
      if (createdTimes.length === 0) break;
      const oldestTs = Math.min(...createdTimes);

      // If we received less than a full page, likely we've got everything
      if (feeds.length < pageSize) {
        keepGoing = false;
        break;
      }

      // Prepare next loop: set 'end' to just before the oldest timestamp we got
      end = new Date(oldestTs - 1000);
      round++;

      // polite delay to avoid rate issues with ThingSpeak
      await new Promise(r => setTimeout(r, 500));
    }

    // Final: sort ascending (old -> new) by created_at
    allFeeds.sort((a, b) => {
      const ta = Date.parse(a.created_at) || 0;
      const tb = Date.parse(b.created_at) || 0;
      return ta - tb;
    });

    // Optionally final dedupe by entry_id (keep first occurrence)
    const final = [];
    const seen = new Set();
    for (const f of allFeeds) {
      const id = f.entry_id ? String(f.entry_id) : (f.created_at + '|' + JSON.stringify([f.field1,f.field2,f.field3,f.field4,f.field5,f.field6,f.field7]));
      if (seen.has(id)) continue;
      seen.add(id);
      final.push(f);
    }

    cachedFeeds = final;
    // console.log('Fetched total', final.length);
    return final;
  } finally {
    showLoading(false);
  }
}

function filterFeedsByRange(feeds, rangeKey) {
  if (!feeds || !feeds.length) return [];
  const now = Date.now();
  const dur = rangeDurationsMs[rangeKey] ?? Infinity;
  if (!isFinite(dur)) return feeds.slice(); // 'all' -> return all
  const cutoff = now - dur;
  const res = feeds.filter(f => {
    if (!f.created_at) return false;
    const t = Date.parse(f.created_at);
    return !isNaN(t) && t >= cutoff;
  });
  return res;
}

function extractSeries(feeds, fieldKey) {
  const labels = [];
  const values = [];
  for (const f of feeds) {
    if (!f.created_at) continue;
    const raw = f[fieldKey];
    const v = raw !== null && raw !== undefined ? parseFloat(raw) : NaN;
    if (!isFinite(v)) continue;
    const dt = new Date(f.created_at);
    if (isNaN(dt)) continue;
    labels.push(dt);
    values.push(v);
  }
  return { labels, values };
}

function downsample(labels, values) {
  const n = labels.length;
  if (n <= maxPoints) return { labels, values };
  const step = Math.ceil(n / maxPoints);
  const newLabels = [];
  const newValues = [];
  for (let i = 0; i < n; i += step) {
    newLabels.push(labels[i]);
    newValues.push(values[i]);
  }
  return { labels: newLabels, values: newValues };
}

function getTimeScaleConfig(rangeKey) {
  switch (rangeKey) {
    case '1h':
      return { unit: 'minute', displayFormats: { minute: 'HH:mm' }, ticks: { maxTicksLimit: 6 } };
    case '24h':
      return { unit: 'hour', displayFormats: { hour: 'HH:mm' }, ticks: { maxTicksLimit: 6 } };
    case '7d':
      return { unit: false, displayFormats: { hour: 'dd MMM' }, ticks: { maxTicksLimit: 10 } };
    case '30d':
      return { unit: 'day', displayFormats: { day: 'dd MMM' }, ticks: { maxTicksLimit: 12 } };
    case '1y':
      return { unit: 'month', displayFormats: { month: 'MMM yyyy' }, ticks: { maxTicksLimit: 12 } };
    default:
      return { unit: 'month', displayFormats: { month: 'MMM yyyy' }, ticks: { maxTicksLimit: 10 } };
  }
}

function createOrUpdateChart(labels, values, labelName, color, rangeKey) {
  const ctx = document.getElementById('dataChart').getContext('2d');
  const scaleCfg = getTimeScaleConfig(rangeKey);

  const dataset = {
    label: labelName,
    data: values.map((v,i) => ({ x: labels[i], y: v })),
    borderColor: color,
    backgroundColor: color.replace('rgb','rgba').replace(')',',0.08)'),
    pointRadius: 0,
    borderWidth: 2,
    tension: 0.25,
  };

  const options = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: { mode: 'index', intersect: false },
    scales: {
      x: {
        type: 'time',
        time: {
          unit: scaleCfg.unit,
          tooltipFormat: 'PPpp',
          displayFormats: scaleCfg.displayFormats
        },
        ticks: { color: '#cbd5e1', autoSkip: true, maxRotation: 0, maxTicksLimit: scaleCfg.ticks?.maxTicksLimit || 6 },
        grid: { color: 'rgba(148,163,184,0.06)' }
      },
      y: {
        ticks: {
          color: '#cbd5e1',
          callback: function(value) {
            if (Math.abs(value) >= 1000) return (value/1000).toFixed(1) + 'k';
            if (Math.abs(value) % 1 === 0) return String(value);
            return Number(value).toFixed(1);
          }
        },
        grid: { color: 'rgba(148,163,184,0.06)' }
      }
    },
    plugins: {
      legend: { labels: { color: '#e2e8f0', boxWidth: 10 } },
      tooltip: {
        backgroundColor: '#1f2937',
        titleColor: '#fff',
        bodyColor: '#fff',
        padding: 8
      }
    },
    elements: { line: { spanGaps: true } }
  };

  if (!chart) {
    chart = new Chart(ctx, { type: 'line', data: { datasets: [dataset] }, options });
  } else {
    chart.data.datasets = [dataset];
    // update time config safely
    if (!chart.options.scales) chart.options.scales = {};
    chart.options.scales.x = chart.options.scales.x || {};
    chart.options.scales.x.time = chart.options.scales.x.time || {};
    chart.options.scales.x.time.unit = scaleCfg.unit;
    chart.options.scales.x.time.displayFormats = scaleCfg.displayFormats;
    chart.options.scales.x.ticks = chart.options.scales.x.ticks || {};
    chart.options.scales.x.ticks.maxTicksLimit = scaleCfg.ticks?.maxTicksLimit || 6;
    chart.update();
  }
}

function plotFieldForRange(feeds, fieldKey, rangeKey) {
  const filtered = filterFeedsByRange(feeds, rangeKey);
  const { labels, values } = extractSeries(filtered, fieldKey);
  if (labels.length === 0) {
    createOrUpdateChart([], [], fieldLabels[fieldKey]?.label || fieldKey, fieldLabels[fieldKey]?.color || 'rgb(148,163,184)', rangeKey);
    return;
  }
  const ds = downsample(labels, values);
  createOrUpdateChart(ds.labels, ds.values, fieldLabels[fieldKey]?.label || fieldKey, fieldLabels[fieldKey]?.color || 'rgb(148,163,184)', rangeKey);
}

/* IAQ gauge functions (unchanged) */
function polarToCartesian(cx, cy, r, angleDeg) { const a = (angleDeg - 90) * Math.PI/180.0; return { x: cx + (r * Math.cos(a)), y: cy + (r * Math.sin(a)) }; }
function describeArcSegment(cx, cy, rOuter, rInner, startAngle, endAngle) {
  const p1 = polarToCartesian(cx, cy, rOuter, endAngle);
  const p2 = polarToCartesian(cx, cy, rOuter, startAngle);
  const largeArcOuter = endAngle - startAngle <= 180 ? "0" : "1";
  const p3 = polarToCartesian(cx, cy, rInner, startAngle);
  const p4 = polarToCartesian(cx, cy, rInner, endAngle);
  const largeArcInner = endAngle - startAngle <= 180 ? "0" : "1";
  const d = ["M", p1.x, p1.y, "A", rOuter, rOuter, 0, largeArcOuter, 0, p2.x, p2.y, "L", p3.x, p3.y, "A", rInner, rInner, 0, largeArcInner, 1, p4.x, p4.y, "Z"].join(" ");
  return d;
}
function drawIAQGauge(value) {
  const svg = document.getElementById('iaqGauge'); if (!svg) return; svg.innerHTML = '';
  const cx = 60, cy = 60, rOuterBase = 44, rInner = 30, segments = iaqGrades.length, segAngle = 360 / segments;
  const thresholds = [50,100,150,200];
  let activeIndex = -1;
  if (isFinite(value)) {
    for (let i=0;i<thresholds.length;i++){ if (value <= thresholds[i]) { activeIndex = i; break; } }
    if (activeIndex === -1) activeIndex = segments-1;
  }
  for (let i=0;i<segments;i++){
    const start = i * segAngle, end = start + segAngle;
    const isActive = i === activeIndex;
    const rOuter = isActive ? rOuterBase + 8 : rOuterBase;
    const pathD = describeArcSegment(cx, cy, rOuter, rInner, start, end);
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', pathD);
    path.setAttribute('fill', iaqGrades[i].color);
    path.setAttribute('class', 'iaq-segment' + (isActive ? ' iaq-active' : ''));
    path.setAttribute('data-idx', i);
    svg.appendChild(path);
  }
  const innerCircle = document.createElementNS('http://www.w3.org/2000/svg','circle');
  innerCircle.setAttribute('cx', cx); innerCircle.setAttribute('cy', cy); innerCircle.setAttribute('r', rInner-1); innerCircle.setAttribute('fill', '#0f172a');
  svg.appendChild(innerCircle);
  const valueEl = document.getElementById('iaqValue'), gradeEl = document.getElementById('iaqGradeLabel');
  if (!isFinite(value)) { if (valueEl) valueEl.innerText='--'; if (gradeEl) gradeEl.innerText='--'; } else {
    const grade = iaqGrades[Math.max(0, activeIndex)];
    if (valueEl && gradeEl) { valueEl.innerText = Number(value).toFixed(2); gradeEl.innerText = grade.name; valueEl.style.color = grade.color; }
  }
  Array.from(svg.querySelectorAll('.iaq-segment')).forEach(p => {
    p.onmouseenter = () => { const idx = Number(p.getAttribute('data-idx')||0); const el = document.getElementById('iaqGradeLabel'); if (el) el.innerText = iaqGrades[idx].name; p.style.transform='scale(1.03)'; };
    p.onmouseleave = () => { const idxActive = activeIndex; const el = document.getElementById('iaqGradeLabel'); if (el) el.innerText = iaqGrades[Math.max(0, idxActive)].name; p.style.transform=''; };
  });
}

async function updateDashboard() {
  try {
    const feeds = await getData();
    if (!Array.isArray(feeds) || feeds.length === 0) {
      document.getElementById('lastUpdate').innerText = "Aucune donnée disponible.";
      return;
    }
    const latest = feeds[feeds.length - 1];
    document.getElementById('tempValue').innerText = isFinite(parseFloat(latest.field1)) ? parseFloat(latest.field1).toFixed(1) + " °C" : "-- °C";
    document.getElementById('pressureValue').innerText = isFinite(parseFloat(latest.field2)) ? (parseFloat(latest.field2)/100).toFixed(1) + " hPa" : "-- hPa";
    document.getElementById('moistureValue').innerText = isFinite(parseFloat(latest.field3)) ? parseFloat(latest.field3).toFixed(1) + " %" : "-- %";
    const iaqRaw = parseFloat(latest.field4);
    document.getElementById('iaqValue').innerText = isFinite(iaqRaw) ? iaqRaw.toFixed(2) : "--";
    drawIAQGauge(isFinite(iaqRaw) ? iaqRaw : NaN);
    document.getElementById('iaqprecisionValue').innerText = isFinite(parseFloat(latest.field5)) ? parseFloat(latest.field5).toFixed(1) : "--";
    document.getElementById('co2value').innerText = isFinite(parseFloat(latest.field6)) ? parseFloat(latest.field6).toFixed(1) + " ppm" : "--";
    document.getElementById('vocValue').innerText = isFinite(parseFloat(latest.field7)) ? parseFloat(latest.field7).toFixed(1) + " ppm" : "--";
    if (latest.created_at) {
      document.getElementById('lastUpdate').innerText = "Les dernières données météorologiques datent de : " + new Date(latest.created_at).toLocaleString();
    } else {
      document.getElementById('lastUpdate').innerText = "Dernière mise à jour : --";
    }
    const variable = document.getElementById('variableSelect')?.value || 'field1';
    const range = document.getElementById('timeRangeSelect')?.value || '24h';
    plotFieldForRange(feeds, variable, range);
  } catch (err) {
    console.error('Failed to update dashboard:', err);
    document.getElementById('lastUpdate').innerText = "Erreur lors de la récupération des données.";
  }
}

// Controls
const variableSelectEl = document.getElementById('variableSelect');
const timeRangeSelectEl = document.getElementById('timeRangeSelect');

if (variableSelectEl) {
  variableSelectEl.addEventListener('change', async () => {
    try {
      const feeds = await getData();
      const range = timeRangeSelectEl?.value || '24h';
      plotFieldForRange(feeds, variableSelectEl.value, range);
    } catch (err) {
      console.error('Error fetching data for chart:', err);
    }
  });
}

if (timeRangeSelectEl) {
  timeRangeSelectEl.addEventListener('change', async () => {
    try {
      const feeds = await getData();
      const variable = variableSelectEl?.value || 'field1';
      plotFieldForRange(feeds, variable, timeRangeSelectEl.value);
    } catch (err) {
      console.error('Error fetching data for chart:', err);
    }
  });
}

// initial load and periodic refresh
updateDashboard();
setInterval(() => { cachedFeeds = null; updateDashboard(); }, 30000);
</script>
</body>
</html>